#! /bin/bash
#   run_extract: extract with magic

#   Copyright 2023 D. Mitch Bailey  cvc at shuharisystem dot com

#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

#  Set LVS parameters in lvs_config file

# Use cases
# run_extract [lvs_config_file [top_layout [layout_file]]]

usage="usage: run_extract [lvs_config_file [top_layout [layout_file]]]"
if [[ $# -gt 3 ]]; then
	echo $usage
	exit 1
fi

CONFIG_FILE=$1
DESIGN_NAME=${2:+"-d $2"}

if [[ $# -ne 0 ]]; then  # if config file not specified, skip and use current environment
	source <($LVS_ROOT/set_lvs_env.py -c $CONFIG_FILE $DESIGN_NAME)
fi
if [[ ! -v EXTRACT_FLATGLOB ]]; then
	echo "Error: LVS environment problem."
	exit 1
fi
export TOP_LAYOUT=${2:-$TOP_LAYOUT}
export LAYOUT_FILE=${3:-$LAYOUT_FILE}

echo " "
echo "Running extract..."

echo "TOP LAYOUT: $TOP_LAYOUT"
echo "LAYOUT FILE: $LAYOUT_FILE"
echo "EXTRACT_FLATGLOB: $(echo $EXTRACT_FLATGLOB | sed -e 's/#[^ ]*//g' -e 's/ /\n /g')"
echo "EXTRACT_ABSTRACT: $(echo $EXTRACT_ABSTRACT | sed -e 's/#[^ ]*//g' -e 's/ /\n /g')"

echo "WORK_ROOT   : ${WORK_ROOT:=$(pwd)/$TOP_SOURCE}"
echo "LOG_ROOT    : ${LOG_ROOT:=$WORK_ROOT}"
echo "SIGNOFF_ROOT: ${SIGNOFF_ROOT:=$WORK_ROOT}"
export LOG_ROOT SIGNOFF_ROOT WORK_ROOT

mkdir -p $LOG_ROOT
mkdir -p $SIGNOFF_ROOT
mkdir -p $WORK_ROOT

# Check for PDK_ROOT and PDK
if [[ -z "$PDK_ROOT" || -z "$PDK" ]]; then
	echo "PDK_ROOT and/or PDK not set."
	exit 1
fi

echo "LOG FILE: $LOG_ROOT/${LOG_FILE:=ext.log}"
rm -f $LOG_ROOT/$LOG_FILE $WORK_ROOT/$LOG_FILE

if cmp -s $PDK_ROOT/$PDK/libs.tech/magic/$PDK.tech $LVS_ROOT/tech/$PDK/$PDK.tech; then
	awk 'NF > 1 && /version/' $LVS_ROOT/tech/$PDK/$PDK.tech
else
	echo "Tech files do not match:"
	grep version $PDK_ROOT/$PDK/libs.tech/magic/$PDK.tech $LVS_ROOT/tech/$PDK/$PDK.tech |
		awk 'NF > 2 && ! /^ *#/'
	echo "Results may be incorrect. Contact efabless to update the soft connection rules."
	#exit 1
fi

if [[ ! -f $WORK_ROOT/layout.cells ]]; then
	$LVS_ROOT/run_hier_check "" "" $TOP_LAYOUT $LAYOUT_FILE "${PDK%?}_([^/_]*_)*_"
fi

# create work abstract file based on actual cells used (psuedo globbing)
# Will work with wildcards directly, but use psuedo globbing to check later.
echo $EXTRACT_FLATGLOB |
	sed 's/  */\n/g' >$WORK_ROOT/flatglob
if [[ -f $WORK_ROOT/layout.cells ]]; then
	sed -e 's/\*/.*/g' -e 's/^/^/' -e 's/$/$/' $WORK_ROOT/flatglob |
		grep -f - $WORK_ROOT/layout.cells >$WORK_ROOT/flatglob.glob
else
	cp $WORK_ROOT/flatglob $WORK_ROOT/flatglob.glob
fi

# create work abstract file based on actual cells used (psuedo globbing)
echo $EXTRACT_ABSTRACT |
	sed 's/  */\n/g' >$WORK_ROOT/abstract
if [[ -f $WORK_ROOT/layout.cells ]]; then
	sed -e 's/\*/.*/g' -e 's/^/^/' -e 's/$/$/' $WORK_ROOT/abstract |
		grep -f - $WORK_ROOT/layout.cells >$WORK_ROOT/abstract.glob
else
	cp $WORK_ROOT/abstract $WORK_ROOT/abstract.glob
fi

# create work subcut file based on actual cells used (psuedo globbing)
echo $EXTRACT_CREATE_SUBCUT |
	sed 's/  */\n/g' >$WORK_ROOT/subcut
if [[ -f $WORK_ROOT/layout.cells ]]; then
	sed -e 's/\*/.*/g' -e 's/^/^/' -e 's/$/$/' $WORK_ROOT/subcut |
		grep -f - $WORK_ROOT/layout.cells >$WORK_ROOT/subcut.glob
else
	cp $WORK_ROOT/abstract $WORK_ROOT/subcut.glob
fi

# Add any cells that should be flattened before extraction to 'flatten'.
export FLATGLOB_CELLS="$(cat $WORK_ROOT/flatglob.glob 2>/dev/null | grep -v '^#')"
# Add any empty cells that should be extracted as black-boxes to 'abstract'.
export ABSTRACT_CELLS="$(cat $WORK_ROOT/abstract.glob 2>/dev/null | grep -v '^#')"
# Add any cells that should be have a subcut layer added.
export SUBCUT_CELLS="$(cat $WORK_ROOT/subcut.glob 2>/dev/null | grep -v '^#')"

# Verify that magic is executable.
if ! which magic >&/dev/null; then
	echo "Error: Could not execute magic."
	exit 1
fi

#  Create extraction result directories. No error if they already exist.
echo "Extracting to ${EXT_DIR:=$WORK_ROOT/ext}"
mkdir -p $EXT_DIR

if [[ ! -f $LAYOUT_FILE ]]; then
	echo "Error: File not found: $LAYOUT_FILE"
	exit 2
fi

# Remove any previous extraction results
rm -rf $EXT_DIR/*.ext{,.gz}

#  1. Extract gds_file
date "+BEGIN: %c" >$WORK_ROOT/$LOG_FILE
start_time=$SECONDS

echo " "
if [[ -z "$EXTRACT_TYPE" && $TOP_LAYOUT == *analog* ]]; then
	EXTRACT_TYPE=analog
fi
if [[ $EXTRACT_TYPE == analog ]]; then
	echo "Extracting as analog. Top ports connected by name." >>$WORK_ROOT/$LOG_FILE
	export EXT_TYPE=analog
	EXT_MESSAGE="connected by name (analog)"
	EXT_TEXT="unique notopports"
else
	echo "Extracting as digital. Top ports unique." >>$WORK_ROOT/$LOG_FILE
	export EXT_TYPE=digital
	EXT_MESSAGE="unique (digital)"
	EXT_TEXT="unique"
fi

# create gds extraction script
cat > $EXT_DIR/extract.tcl <<-EOF
# magic commands to extract netlist.
# well connectivity is detemined by CIFIN_STYLE and EXTRACT_STYLE.
# output directory set by environment variable RUN_DIR

puts "Extracting with top ports $EXT_MESSAGE"
drc off
gds drccheck off
if {[string first sky130 $PDK] >= 0} {
    cif istyle sky130($CIFIN_STYLE)

} elseif {[string first gf180mcu $PDK] >= 0} {
    cif istyle import($CIFIN_STYLE)

} else {
    puts "ERROR: Unknown PDK - $PDK"
    exit 1
}

foreach cell { $FLATGLOB_CELLS } {
	gds flatglob \$cell
}
# list cells to be flattened
puts "Flattening [string map {" " "\n"} [gds flatglob]]"
gds flatten yes ;# Flattens cells with few layers
puts "Extracting $LAYOUT_FILE"
gds read $LAYOUT_FILE

set flatglob_error 0
foreach cell { $FLATGLOB_CELLS } { ;# Check for unflattened flatglob cells.
	if { [llength [cellname list children \$cell]] > 0 } {
		set flatglob_error 1
		puts "Could not flatten \$cell because it contains these subcells:"
		foreach subcell [cellname list children \$cell] {
			puts "  \$subcell"
		}
	}	
}
if { \$flatglob_error } { ;# Quit if there are unflattened flatglob cells.
	exit 1
}

gds flatten no ;# subcut cells will have few shapes, so don't flatten them when reading their gds later.

foreach cell { $SUBCUT_CELLS } {
	# Adds an isosub/subcut layer to the cell.
	# 1. For each cell, create a new cell with an isosub/subcut layer = boundary - ( dnwell | isosub ).
	# 2. Add this new cell to the original cell.
	# 3. Flatten the new cell instance in the original cell.
	load \$cell
	select top cell
	set cellboundary [view bbox] ;# Save the boundary.
	expand
	puts stdout "Creating subcut for \$cell ..."
	set subcut_cell_name \${cell}_subcut
	flatten -nolabels \$subcut_cell_name ;# Flatten into a cell with a new name.
	load \$subcut_cell_name
	property FIXED_BBOX \$cellboundary ;# Reset the boundary after flattening.
	cif ostyle subcutout
	set gds_subcut_file [file join $EXT_DIR \$subcut_cell_name]
	gds write \$gds_subcut_file ;# Write just the subcut layer.
	cellname delete \$subcut_cell_name
	gds read \$gds_subcut_file ;# Read the subcut only cell.
	load \$cell
	select top cell
	getcell \$subcut_cell_name child 0 0 parent 0 0 ;# Place the subcut cell at the origin.
	expand
	flatten -doinplace [instance list self] ;# flatten subcut cell to place subcut layer.
}

foreach cell { $ABSTRACT_CELLS } {
	load \$cell
	property LEFview true
}

cd $EXT_DIR
load $TOP_LAYOUT
select top cell
expand
extract no all
extract do aliases
extract do local
extract $EXT_TEXT
extract style ngspice($EXTRACT_STYLE)
extract

ext2spice lvs
ext2spice merge conservative
ext2spice short resistor
ext2spice -o $TOP_LAYOUT.gds.spice $TOP_LAYOUT.ext
feedback save $TOP_LAYOUT-ext2gds.spice.feedback.txt
EOF

# script uses TOP, RUN_DIR, CIFIN_STYLE, and EXTRACT_STYLE
magic -dnull -noc -rcfile $LVS_ROOT/tech/magicrc $EXT_DIR/extract.tcl </dev/null 2>&1 |
	tee -a $WORK_ROOT/$LOG_FILE
ext_status=${PIPESTATUS[0]}

date "+END: %c" >>$WORK_ROOT/$LOG_FILE
runtime=$((SECONDS - start_time))
hours=$((runtime / 3600))
minutes=$(((runtime % 3600) / 60))
seconds=$(((runtime % 3600) % 60))
printf "Runtime: %d:%02d:%02d (hh:mm:ss)\n" $hours $minutes $seconds >>$WORK_ROOT/$LOG_FILE
if [[ $WORK_ROOT != $LOG_ROOT ]]; then
	cp $WORK_ROOT/$LOG_FILE $LOG_ROOT/$LOG_FILE
fi

# Create extracted hierarchy
echo "Creating layout hierarchy in $EXT_DIR/$TOP_LAYOUT.hier..."
awk -f $LVS_ROOT/scripts/ext.hier.awk -v TOP=$TOP_LAYOUT $EXT_DIR/*.ext >$EXT_DIR/$TOP_LAYOUT.hier

# Compress large ext files
find $EXT_DIR -name '*.ext' -size +1M -exec gzip {} \;

# Check that extraction completed successfully
if [[ ${magic_status:=0} -ne 0 || $(grep -c 'exttospice finished.' $LOG_ROOT/$LOG_FILE) -ne 1 ]]; then
	echo "
Error: extraction did not complete successfully"
	exit 4
fi

